# bit全探索

<!-- START doctoc -->
<!-- END doctoc -->

## Rustでの実装

Rustでは `<<` 演算子を使用することで左シフトの演算を実行することができる。

左シフト演算を使用することで、以下のようび `2^N` の値を2進数で表現することができる。

```rust
println!("{0:02}, {0:05b}", 1 << 0); // 01: 00001 
println!("{0:02}, {0:05b}", 1 << 1); // 02: 00010
println!("{0:02}, {0:05b}", 1 << 2); // 04: 00100
println!("{0:02}, {0:05b}", 1 << 3); // 08: 01000
println!("{0:02}, {0:05b}", 1 << 4); // 16: 10000
```

bit全探索を計算するためには、以下のように0からnの直前までの10進数に対する2進数表現を取得する必要がある。

```bash
000
001
010
011
100
101
110
111
```

そこでbit値に対して `AND` 演算を利用する。

ただし以下のように単純な組み合わせを実行してしまうと、値が0であるパターンを複数回抽出してしまう。

```rust
// 以下で bit は [0000, 0001, 0010, 0011, 0100, ..., 1111] となる
for bit in 0..(1 << 4) {
    // 配列からbit値の1に該当する要素を抽出する
}
```

上記を実行すれば以下のような出力が得られる。

```bash
00: 0000
01: 0001
02: 0010
03: 0011
04: 0100
05: 0101
06: 0110
07: 0111
08: 1000
09: 1001
10: 1010
11: 1011
12: 1100
13: 1101
14: 1110
15: 1111
```

上記の出力結果の中から値が1になっている要素を配列から抽出する。
そのためには、値が1になっている部分の配列のインデックスを取得する必要がある。

```bash
# 配列が以下の状態になっているとする
A B C D
0 1 2 3

# bit値が [0010] の場合には以下を抽出する
0000: 
0001: A
0010: B
0011: A B
0100: C
0101: A C
0110: B C
0111: A B C
1000: D
1001: A D
1010: B D
1011: A B D
1100: C D
1101: A C D
1110: B C D
1111: A B C D
```

このために配列のインデックスが `i` の値を抽出するためには、bit値の `i` 桁目が1で他が0であるような値との `AND` 演算を計算すればいい。

```rust
let list = vec!["A", "B", "C", "D"];

// 以下では [0000, 0001, 0010, 0011, 0100, ..., 1111] と探索する
for bit in 0..(1 << 4) {
    // 以下では bit値の i桁目が1である配列要素を抽出する
    for i in 0..4 {
        // AND演算を実施する
        println!("{:04b} & {:04b} = {:04b}", bit, 1 << i, bit & (1 << i));
    }
}
```

これで以下のような結果が得られる。

```bash
0000 & 0001 = 0000
0000 & 0010 = 0000
0000 & 0100 = 0000
0000 & 1000 = 0000
0001 & 0001 = 0001
0001 & 0010 = 0000
0001 & 0100 = 0000
0001 & 1000 = 0000
0010 & 0001 = 0000
0010 & 0010 = 0010
0010 & 0100 = 0000
0010 & 1000 = 0000
0011 & 0001 = 0001
0011 & 0010 = 0010
0011 & 0100 = 0000
0011 & 1000 = 0000
0100 & 0001 = 0000
0100 & 0010 = 0000
0100 & 0100 = 0100
0100 & 1000 = 0000
0101 & 0001 = 0001
0101 & 0010 = 0000
0101 & 0100 = 0100
0101 & 1000 = 0000
0110 & 0001 = 0000
0110 & 0010 = 0010
0110 & 0100 = 0100
0110 & 1000 = 0000
0111 & 0001 = 0001
0111 & 0010 = 0010
0111 & 0100 = 0100
0111 & 1000 = 0000
1000 & 0001 = 0000
1000 & 0010 = 0000
1000 & 0100 = 0000
1000 & 1000 = 1000
1001 & 0001 = 0001
1001 & 0010 = 0000
1001 & 0100 = 0000
1001 & 1000 = 1000
1010 & 0001 = 0000
1010 & 0010 = 0010
1010 & 0100 = 0000
1010 & 1000 = 1000
1011 & 0001 = 0001
1011 & 0010 = 0010
1011 & 0100 = 0000
1011 & 1000 = 1000
1100 & 0001 = 0000
1100 & 0010 = 0000
1100 & 0100 = 0100
1100 & 1000 = 1000
1101 & 0001 = 0001
1101 & 0010 = 0000
1101 & 0100 = 0100
1101 & 1000 = 1000
1110 & 0001 = 0000
1110 & 0010 = 0010
1110 & 0100 = 0100
1110 & 1000 = 1000
1111 & 0001 = 0001
1111 & 0010 = 0010
1111 & 0100 = 0100
1111 & 1000 = 1000
```

上記の結果から例えば以下の結果から配列をどのように抽出できるのか確認する。

```bash
# 配列からは [0111] 、つまり配列から [A B C] を抽出する
# この場合には i桁目が1になっているのかAND演算を行って抽出する
0111 & 0001 = 0001 # 1桁目が1 -> A
0111 & 0010 = 0010 # 2桁目が1 -> B
0111 & 0100 = 0100 # 3桁目が1 -> C
0111 & 1000 = 0000 # 4桁目が0
```

つまり上記のループを計算している際に、`AND` 演算結果が0ではないもの場合から配列のインデックスを指定して抽出する。

```rust
let list = vec!["A", "B", "C", "D"];

// 以下では [0000, 0001, 0010, 0011, 0100, ..., 1111] と探索する
for bit in 0..(1 << 4) {
    let mut s = Vec::new();
    // 以下では bit値の i桁目が1である配列要素を抽出する
    for i in 0..4 {
        // AND演算を実施し、0の値を省くようにする
        if bit & (1 << i) != 0b0 {
            s.push(list[i])
        }
    }

    print!("{:04b} -> ", bit);
    for i in s.iter() {
        print!("{} ", i);
    }
    println!("");
}
```

この計算を実施すれば、一番外側のループを通して以下のような抽出結果を取得することができる。

```bash
0000 -> 
0001 -> A 
0010 -> B 
0011 -> A B 
0100 -> C 
0101 -> A C 
0110 -> B C 
0111 -> A B C 
1000 -> D 
1001 -> A D 
1010 -> B D 
1011 -> A B D 
1100 -> C D 
1101 -> A C D 
1110 -> B C D 
1111 -> A B C D 
```

これでbit値を使用することで、配列の要素から全ての組み合わせを抽出することができていることを確認できる。

なおループを見ればわかるように、計算量は `O(N * 2^N)` になる。
